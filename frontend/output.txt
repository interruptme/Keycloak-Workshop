This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
public/
  silent-check-sso.html
src/
  router/
    index.js
  services/
    api.service.js
    auth.service.js
  views/
    CallbackView.vue
    HomeView.vue
    LoginView.vue
    ProfileView.vue
  App.vue
  main.js
index.html
package.json
README.md
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/silent-check-sso.html">
<!DOCTYPE html>
<html>
  <head>
    <title>Silent SSO Check</title>
    <script>
      parent.postMessage(location.href, location.origin);
    </script>
  </head>
  <body>
    <!-- This file is used for silent token refresh -->
  </body>
</html>
</file>

<file path="src/router/index.js">
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'
import LoginView from '../views/LoginView.vue'
import ProfileView from '../views/ProfileView.vue'
import authService from '../services/auth.service.js'

const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/login',
    name: 'login',
    component: LoginView
  },
  {
    path: '/profile',
    name: 'profile',
    component: ProfileView,
    meta: { requiresAuth: true }
  },
  {
    path: '/callback',
    name: 'callback',
    component: () => import('../views/CallbackView.vue')
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// Navigation guard
router.beforeEach(async (to, from, next) => {
  // Check if route requires authentication
  if (to.matched.some(record => record.meta.requiresAuth)) {
    if (!authService.state.isInitialized) {
      // Wait for auth service to initialize
      try {
        await authService.initKeycloak()
      } catch (error) {
        console.error('Failed to initialize Keycloak', error)
      }
    }

    if (!authService.state.isAuthenticated) {
      // Redirect to login page with return URL
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else if (authService.tokenExpired.value) {
      // Try to refresh token
      try {
        await authService.updateToken()
        next()
      } catch (error) {
        next({
          path: '/login',
          query: { redirect: to.fullPath }
        })
      }
    } else {
      next()
    }
  } else {
    // Initialize auth if not already initialized
    if (!authService.state.isInitialized) {
      try {
        await authService.initKeycloak()
      } catch (error) {
        console.error('Failed to initialize Keycloak', error)
      }
    }
    next()
  }
})

export default router
</file>

<file path="src/services/api.service.js">
import axios from 'axios';
import authService from './auth.service';

// Create an axios instance
const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  },
  timeout: 10000 // Request timeout: 10 seconds
});

// Request interceptor for API calls
apiClient.interceptors.request.use(
  async (config) => {
    // Check if user is authenticated
    if (authService.state.isAuthenticated) {
      try {
        // Check if token needs refresh (if it will expire in the next 60 seconds)
        if (authService.tokenExpired.value) {
          await authService.updateToken();
        }
        
        // Get the current token
        const token = authService.getToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
      } catch (error) {
        console.error('Error refreshing token in request interceptor', error);
      }
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor for API calls
apiClient.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    const originalRequest = error.config;
    
    // If error is 401 and we haven't tried to refresh token yet
    if (error.response && error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // Try to refresh the token
        await authService.updateToken();
        
        // Get new token and update the request
        const token = authService.getToken();
        if (token) {
          originalRequest.headers.Authorization = `Bearer ${token}`;
          return apiClient(originalRequest);
        }
      } catch (refreshError) {
        // If refresh token fails, redirect to login
        console.error('Token refresh failed', refreshError);
        
        // Force logout
        try {
          await authService.logout();
        } catch (logoutError) {
          console.error('Logout failed', logoutError);
        }
        
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

export default {
  // Basic API methods
  get(url, params = {}) {
    return apiClient.get(url, { params });
  },
  
  post(url, data = {}) {
    return apiClient.post(url, data);
  },
  
  put(url, data = {}) {
    return apiClient.put(url, data);
  },
  
  delete(url) {
    return apiClient.delete(url);
  },
  
  // Exposed axios instance for more complex usage
  client: apiClient
};
</file>

<file path="src/services/auth.service.js">
import Keycloak from 'keycloak-js';
import { ref, reactive, computed } from '@vue/reactivity';

// Create reactive state
const keycloakInstance = ref(null);
const state = reactive({
  isAuthenticated: false,
  isInitialized: false,
  userProfile: null,
  authError: null,
  keycloakReady: false,
  tokenExpiration: null
});

// Initialize Keycloak instance
const initKeycloak = () => {
  const keycloakConfig = {
    url: import.meta.env.VITE_KEYCLOAK_URL,
    realm: import.meta.env.VITE_KEYCLOAK_REALM,
    clientId: import.meta.env.VITE_KEYCLOAK_CLIENT_ID
  };

  keycloakInstance.value = new Keycloak(keycloakConfig);

  return keycloakInstance.value
    .init({
      onLoad: 'check-sso', // Don't auto-login
      pkceMethod: 'S256', // Use PKCE for added security
      checkLoginIframe: false, // Disable iframe check for cross-origin issues
      silentCheckSsoRedirectUri: `${window.location.origin}/silent-check-sso.html`,
    })
    .then((authenticated) => {
      state.isAuthenticated = authenticated;
      state.isInitialized = true;
      state.keycloakReady = true;
      
      if (authenticated) {
        updateTokenExpiration();
        return loadUserProfile();
      }
      
      return authenticated;
    })
    .catch((error) => {
      state.authError = error;
      state.isInitialized = true;
      console.error('Keycloak initialization error', error);
      throw error;
    });
};

// Load user profile if authenticated
const loadUserProfile = () => {
  if (!keycloakInstance.value || !state.isAuthenticated) {
    return Promise.reject(new Error('Not authenticated'));
  }

  return keycloakInstance.value
    .loadUserProfile()
    .then((profile) => {
      state.userProfile = profile;
      return profile;
    })
    .catch((error) => {
      console.error('Error loading user profile', error);
      throw error;
    });
};

// Login function
const login = (redirectUri = window.location.href) => {
  if (!keycloakInstance.value) {
    return Promise.reject(new Error('Keycloak not initialized'));
  }
  
  return keycloakInstance.value.login({
    redirectUri,
    prompt: 'login',
  });
};

// Logout function
const logout = () => {
  if (!keycloakInstance.value) {
    return Promise.reject(new Error('Keycloak not initialized'));
  }
  
  return keycloakInstance.value.logout();
};

// Update token expiration time
const updateTokenExpiration = () => {
  if (keycloakInstance.value && keycloakInstance.value.token) {
    // Parse JWT to get expiration
    try {
      const tokenParts = keycloakInstance.value.token.split('.');
      const tokenPayload = JSON.parse(atob(tokenParts[1]));
      state.tokenExpiration = tokenPayload.exp * 1000; // Convert to milliseconds
    } catch (error) {
      console.error('Error parsing token', error);
    }
  }
};

// Get auth token
const getToken = () => {
  if (!keycloakInstance.value || !state.isAuthenticated) {
    return null;
  }
  return keycloakInstance.value.token;
};

// Update token - returns a promise
const updateToken = (minValidity = 60) => {
  if (!keycloakInstance.value || !state.isAuthenticated) {
    return Promise.reject(new Error('Not authenticated'));
  }
  
  return keycloakInstance.value
    .updateToken(minValidity)
    .then((refreshed) => {
      if (refreshed) {
        updateTokenExpiration();
      }
      return keycloakInstance.value.token;
    })
    .catch((error) => {
      console.error('Failed to refresh token', error);
      return logout();
    });
};

// Computed value for token expiration
const tokenExpired = computed(() => {
  if (!state.tokenExpiration) return true;
  return state.tokenExpiration <= Date.now();
});

// Handle token expiration
const setupTokenRefresh = () => {
  if (!keycloakInstance.value || !state.isAuthenticated) return;
  
  // Schedule token refresh at 70% of token lifetime
  const tokenUpdateInterval = setInterval(() => {
    if (!state.isAuthenticated) {
      clearInterval(tokenUpdateInterval);
      return;
    }
    
    updateToken()
      .catch(() => {
        clearInterval(tokenUpdateInterval);
      });
  }, 60000); // Check every minute
  
  // Cleanup on unmount
  return () => {
    clearInterval(tokenUpdateInterval);
  };
};

// Check if user has specific role
const hasRole = (role) => {
  if (!keycloakInstance.value || !state.isAuthenticated) {
    return false;
  }
  return keycloakInstance.value.hasRealmRole(role);
};

export default {
  state,
  initKeycloak,
  login,
  logout,
  getToken,
  updateToken,
  hasRole,
  setupTokenRefresh,
  tokenExpired
};
</file>

<file path="src/views/CallbackView.vue">
<template>
  <div class="callback">
    <div class="loading-container">
      <div class="spinner"></div>
      <p>{{ statusMessage }}</p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import authService from '../services/auth.service'

const router = useRouter()
const route = useRoute()
const statusMessage = ref('Processing login...')

onMounted(async () => {
  try {
    // Check URL for authentication code
    const urlParams = new URLSearchParams(window.location.search)
    const code = urlParams.get('code')
    
    if (!code) {
      statusMessage.value = 'Error: No authentication code found in URL'
      setTimeout(() => {
        router.push('/login')
      }, 2000)
      return
    }
    
    // In a real implementation, we would have to process the code and exchange it for tokens
    // For Keycloak JS, this would typically be handled by the library
    // Just validate that auth is working
    if (!authService.state.isInitialized) {
      await authService.initKeycloak()
    }
    
    if (!authService.state.isAuthenticated) {
      statusMessage.value = 'Error: Authentication failed'
      setTimeout(() => {
        router.push('/login')
      }, 2000)
      return
    }
    
    // Check for a redirect URL in the state
    statusMessage.value = 'Login successful, redirecting...'
    
    // If profile not loaded, load it
    if (!authService.state.userProfile) {
      await authService.loadUserProfile()
    }
    
    // Set up token refresh
    authService.setupTokenRefresh()
    
    // Redirect to target location or home
    setTimeout(() => {
      const redirectPath = route.query.redirect || '/'
      router.push(redirectPath)
    }, 1000)
  } catch (error) {
    console.error('Error processing callback', error)
    statusMessage.value = 'An error occurred during login'
    
    setTimeout(() => {
      router.push('/login')
    }, 2000)
  }
})
</script>

<style scoped>
.callback {
  height: 60vh;
  display: flex;
  justify-content: center;
  align-items: center;
}

.loading-container {
  text-align: center;
}

.spinner {
  display: inline-block;
  width: 50px;
  height: 50px;
  border: 3px solid rgba(66, 185, 131, 0.2);
  border-radius: 50%;
  border-top-color: #42b983;
  animation: spin 1s ease-in-out infinite;
  margin-bottom: 1rem;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
</style>
</file>

<file path="src/views/HomeView.vue">
<template>
  <div class="home">
    <h1>Welcome to the Keycloak Demo App</h1>
    
    <div class="card">
      <p>This is a demonstration of Vue 3 integration with Keycloak for authentication.</p>
      
      <div v-if="isAuthenticated" class="auth-status">
        <p>You are currently logged in as <strong>{{ username }}</strong>.</p>
        <router-link to="/profile" class="btn">View Profile</router-link>
      </div>
      
      <div v-else class="auth-status">
        <p>You are not currently logged in.</p>
        <router-link to="/login" class="btn">Login</router-link>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import authService from '../services/auth.service'

// Computed property to check if user is authenticated
const isAuthenticated = computed(() => authService.state.isAuthenticated)

// Computed property to get username
const username = computed(() => {
  if (authService.state.userProfile) {
    return authService.state.userProfile.username || 
           authService.state.userProfile.preferred_username || 
           'User'
  }
  return 'User'
})
</script>

<style scoped>
.home {
  padding: 1rem;
}

.card {
  background-color: #f8f9fa;
  border-radius: 8px;
  padding: 2rem;
  margin: 2rem auto;
  max-width: 600px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.auth-status {
  margin-top: 1.5rem;
  padding: 1rem;
  background-color: #e9ecef;
  border-radius: 4px;
}

.btn {
  display: inline-block;
  margin-top: 1rem;
  padding: 0.5rem 1rem;
  background-color: #42b983;
  color: white;
  border-radius: 4px;
  text-decoration: none;
  font-weight: bold;
}

.btn:hover {
  background-color: #3aa876;
}
</style>
</file>

<file path="src/views/LoginView.vue">
<template>
  <div class="login">
    <h1>Login</h1>
    
    <div class="card">
      <div v-if="isAuthenticated" class="auth-status">
        <p>You are already logged in as <strong>{{ username }}</strong>.</p>
        <div class="button-group">
          <router-link to="/" class="btn btn-secondary">Go Home</router-link>
          <router-link to="/profile" class="btn">View Profile</router-link>
        </div>
      </div>
      
      <div v-else class="login-form">
        <p>Click the button below to log in using Keycloak:</p>
        <div v-if="authError" class="error-message">
          <p>{{ authError }}</p>
        </div>
        <button @click="login" class="btn" :disabled="isLoading">
          {{ isLoading ? 'Redirecting to login...' : 'Login with Keycloak' }}
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import authService from '../services/auth.service'

const route = useRoute()
const router = useRouter()
const isLoading = ref(false)
const authError = ref(null)

// Computed property to check if user is authenticated
const isAuthenticated = computed(() => authService.state.isAuthenticated)

// Computed property to get username
const username = computed(() => {
  if (authService.state.userProfile) {
    return authService.state.userProfile.username || 
           authService.state.userProfile.preferred_username || 
           'User'
  }
  return 'User'
})

// Login function
const login = async () => {
  try {
    isLoading.value = true
    authError.value = null
    
    // Get redirect URL from query params or use home page
    const redirectUri = route.query.redirect || '/'
    
    // Call login method from auth service
    await authService.login(window.location.origin + redirectUri)
  } catch (error) {
    console.error('Login failed', error)
    authError.value = 'Login failed. Please try again.'
    isLoading.value = false
  }
}

// Check if user is already authenticated, redirect to requested page
onMounted(() => {
  if (isAuthenticated.value) {
    const redirectUri = route.query.redirect
    if (redirectUri) {
      router.push(redirectUri)
    }
  }
})
</script>

<style scoped>
.login {
  padding: 1rem;
}

.card {
  background-color: #f8f9fa;
  border-radius: 8px;
  padding: 2rem;
  margin: 2rem auto;
  max-width: 600px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.auth-status, .login-form {
  margin-top: 1rem;
  padding: 1rem;
  background-color: #e9ecef;
  border-radius: 4px;
}

.button-group {
  display: flex;
  gap: 1rem;
  justify-content: center;
  margin-top: 1rem;
}

.btn {
  display: inline-block;
  padding: 0.5rem 1rem;
  background-color: #42b983;
  color: white;
  border: none;
  border-radius: 4px;
  text-decoration: none;
  font-weight: bold;
  cursor: pointer;
}

.btn:hover {
  background-color: #3aa876;
}

.btn:disabled {
  background-color: #89d6b3;
  cursor: not-allowed;
}

.btn-secondary {
  background-color: #6c757d;
}

.btn-secondary:hover {
  background-color: #5a6268;
}

.error-message {
  margin: 1rem 0;
  padding: 0.5rem;
  color: #721c24;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
}
</style>
</file>

<file path="src/views/ProfileView.vue">
<template>
  <div class="profile">
    <h1>User Profile</h1>
    
    <div class="card">
      <div v-if="isLoading" class="loading">
        Loading profile information...
      </div>
      
      <div v-else-if="userProfile" class="profile-info">
        <div class="avatar">
          {{ userInitials }}
        </div>
        
        <h2>{{ userProfile.firstName }} {{ userProfile.lastName }}</h2>
        
        <div class="profile-details">
          <div class="profile-row">
            <strong>Username:</strong>
            <span>{{ userProfile.username }}</span>
          </div>
          
          <div class="profile-row">
            <strong>Email:</strong>
            <span>{{ userProfile.email }}</span>
          </div>
          
          <div v-if="userRoles.length > 0" class="profile-row">
            <strong>Roles:</strong>
            <span>{{ userRoles.join(', ') }}</span>
          </div>
          
          <div class="profile-row">
            <strong>Account Created:</strong>
            <span>{{ createdDate }}</span>
          </div>
        </div>
        
        <div class="token-info">
          <h3>Token Information</h3>
          <div class="profile-row">
            <strong>Token Expires:</strong>
            <span>{{ tokenExpiryFormatted }}</span>
          </div>
          
          <button @click="refreshToken" class="btn btn-small">
            Refresh Token
          </button>
        </div>
      </div>
      
      <div v-else class="error-message">
        <p>Unable to load profile. Please ensure you are logged in.</p>
        <router-link to="/login" class="btn">Go to Login</router-link>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import authService from '../services/auth.service'

const isLoading = ref(true)

// Get user profile from auth service
const userProfile = computed(() => authService.state.userProfile)

// Check if authenticated
const isAuthenticated = computed(() => authService.state.isAuthenticated)

// Get user initials for avatar
const userInitials = computed(() => {
  if (!userProfile.value) return '?'
  
  const first = userProfile.value.firstName ? userProfile.value.firstName.charAt(0) : ''
  const last = userProfile.value.lastName ? userProfile.value.lastName.charAt(0) : ''
  
  return (first + last).toUpperCase()
})

// Format token expiration time
const tokenExpiryFormatted = computed(() => {
  if (!authService.state.tokenExpiration) return 'Unknown'
  
  const expiryDate = new Date(authService.state.tokenExpiration)
  const now = new Date()
  const diffMs = expiryDate - now
  
  // If already expired
  if (diffMs <= 0) return 'Expired'
  
  // Format remaining time
  const diffMins = Math.floor(diffMs / 60000)
  const diffSecs = Math.floor((diffMs % 60000) / 1000)
  
  return `${diffMins}m ${diffSecs}s (${expiryDate.toLocaleTimeString()})`
})

// Mock user roles - in a real app, you would get these from the token
const userRoles = computed(() => {
  // Check if we have a token and it contains realm_access.roles
  const token = authService.getToken()
  if (!token) return []
  
  try {
    const tokenParts = token.split('.')
    const tokenPayload = JSON.parse(atob(tokenParts[1]))
    
    // Check if realm_access roles exist
    if (tokenPayload.realm_access && Array.isArray(tokenPayload.realm_access.roles)) {
      return tokenPayload.realm_access.roles
    }
    
    return []
  } catch (error) {
    console.error('Error parsing token for roles', error)
    return []
  }
})

// Mock created date - in a real app, you might get this from the user profile
const createdDate = computed(() => {
  return new Date().toLocaleDateString()
})

// Refresh the token
const refreshToken = async () => {
  try {
    await authService.updateToken(30)
  } catch (error) {
    console.error('Error refreshing token', error)
  }
}

// On component mount
onMounted(async () => {
  isLoading.value = true
  
  try {
    // If not authenticated, the router guard would have redirected
    // But we double-check here
    if (!isAuthenticated.value) {
      isLoading.value = false
      return
    }
    
    // If we haven't loaded the profile yet, load it
    if (!userProfile.value) {
      await authService.loadUserProfile()
    }
  } catch (error) {
    console.error('Error loading profile', error)
  } finally {
    isLoading.value = false
  }
})
</script>

<style scoped>
.profile {
  padding: 1rem;
}

.card {
  background-color: #f8f9fa;
  border-radius: 8px;
  padding: 2rem;
  margin: 2rem auto;
  max-width: 600px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.loading {
  text-align: center;
  padding: 2rem 0;
  color: #6c757d;
}

.profile-info {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background-color: #42b983;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  font-weight: bold;
  margin-bottom: 1rem;
}

.profile-details {
  width: 100%;
  margin-top: 1rem;
}

.profile-row {
  display: flex;
  justify-content: space-between;
  padding: 0.5rem 0;
  border-bottom: 1px solid #dee2e6;
}

.profile-row:last-child {
  border-bottom: none;
}

.token-info {
  margin-top: 2rem;
  padding: 1rem;
  background-color: #e9ecef;
  border-radius: 4px;
  width: 100%;
}

.btn {
  display: inline-block;
  padding: 0.5rem 1rem;
  background-color: #42b983;
  color: white;
  border: none;
  border-radius: 4px;
  text-decoration: none;
  font-weight: bold;
  cursor: pointer;
  margin-top: 1rem;
}

.btn:hover {
  background-color: #3aa876;
}

.btn-small {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
}

.error-message {
  padding: 1rem;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
  color: #721c24;
  text-align: center;
}
</style>
</file>

<file path="src/App.vue">
<template>
  <div class="app-container">
    <header>
      <nav>
        <router-link to="/">Home</router-link> |
        <router-link v-if="isAuthenticated" to="/profile">Profile</router-link>
        <template v-if="isAuthenticated">
          | <a href="#" @click.prevent="logout">Logout</a>
        </template>
        <template v-else>
          | <router-link to="/login">Login</router-link>
        </template>
      </nav>
    </header>
    
    <main>
      <router-view />
    </main>
    
    <footer>
      <p>Keycloak Vue Demo Application</p>
    </footer>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import authService from './services/auth.service'

const router = useRouter()

// Computed property to check if user is authenticated
const isAuthenticated = computed(() => authService.state.isAuthenticated)

// Logout function
const logout = async () => {
  try {
    await authService.logout()
    // Keycloak will handle the redirect to its logout page
  } catch (error) {
    console.error('Logout failed', error)
  }
}
</script>

<style>
.app-container {
  font-family: Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  max-width: 1200px;
  margin: 0 auto;
  padding: 1rem;
}

header {
  padding: 1rem 0;
  margin-bottom: 2rem;
  border-bottom: 1px solid #eaeaea;
}

nav {
  padding: 1rem 0;
}

nav a {
  font-weight: bold;
  color: #2c3e50;
  text-decoration: none;
  margin: 0 0.5rem;
}

nav a.router-link-exact-active {
  color: #42b983;
}

footer {
  margin-top: 2rem;
  padding: 1rem 0;
  border-top: 1px solid #eaeaea;
  font-size: 0.8rem;
  color: #666;
}
</style>
</file>

<file path="src/main.js">
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import authService from './services/auth.service'

// Create the Vue application
const app = createApp(App)

// Add Pinia for state management
app.use(createPinia())

// Add Vue Router
app.use(router)

// Initialize auth service first, then mount the app
authService.initKeycloak()
  .then(() => {
    // If auth initialized successfully, setup token refresh
    if (authService.state.isAuthenticated) {
      authService.setupTokenRefresh()
    }
  })
  .catch(error => {
    console.error('Auth service initialization failed:', error)
  })
  .finally(() => {
    // Mount the app regardless of auth state
    app.mount('#app')
  })
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Keycloak Vue Integration</title>
    <meta name="description" content="A demo application showing Vue 3 integration with Keycloak authentication" />
    <!-- Security headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; connect-src 'self' http://localhost:8080 http://localhost:5000; script-src 'self'; frame-src 'self' http://localhost:8080/; style-src 'self' 'unsafe-inline';" />
    <meta http-equiv="X-Content-Type-Options" content="nosniff" />
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "keycloak-vue-frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint --ext .js,.vue --ignore-path .gitignore --fix src",
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "dependencies": {
    "keycloak-js": "^26.1.4",
    "@vue/reactivity": "^3.4.19",
    "axios": "^1.6.7",
    "pinia": "^2.1.7",
    "vue": "^3.4.19", 
    "vue-router": "^4.2.5"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.4",
    "@vue/test-utils": "^2.4.4",
    "eslint": "^8.57.0",
    "eslint-plugin-vue": "^9.21.1",
    "happy-dom": "^13.6.2",
    "vite": "^5.1.4",
    "vitest": "^1.3.1"
  }
}
</file>

<file path="README.md">
# Vue 3 Keycloak Integration

This project demonstrates the integration of Vue 3 with Keycloak for authentication and authorization.

## Features

- Vue 3 with Composition API
- Vue Router with navigation guards
- Keycloak integration with PKCE flow
- Token refresh handling
- Protected routes
- User profile display
- API service with token handling

## Prerequisites

- Node.js 16+
- npm or yarn
- Running Keycloak instance (see backend README)

## Project Setup

```bash
# Install dependencies
npm install

# Compile and hot-reload for development
npm run dev

# Compile and minify for production
npm run build

# Run unit tests
npm run test

# Lint and fix files
npm run lint
```

## Environment Variables

Create a `.env.local` file with the following variables:

```
VITE_KEYCLOAK_URL=http://localhost:8080
VITE_KEYCLOAK_REALM=demo-realm
VITE_KEYCLOAK_CLIENT_ID=frontend-client
VITE_API_URL=http://localhost:5000/api
```

## Keycloak Configuration

Ensure that your Keycloak server has:

1. A realm named `demo-realm`
2. A public client named `frontend-client` with:
   - Valid redirect URIs for your application (http://localhost:5173/*)
   - Web origins configured
   - PKCE enforced

## Project Structure

- `services/auth.service.js`: Keycloak integration
- `services/api.service.js`: API calls with token handling
- `router/index.js`: Route definitions with auth guards
- `views/`: Page components
- `components/`: Reusable UI components

## Security Features

- PKCE flow for secure authentication
- In-memory token storage (no localStorage)
- Token refresh handling
- CSP headers in index.html

## Development Notes

- The auth service uses Vue 3's reactive system for state management
- Token refresh is handled automatically before API calls
- Protected routes redirect to login if unauthorized
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { fileURLToPath, URL } from 'node:url'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  server: {
    port: 5173,
    cors: true
  }
})
</file>

</files>
